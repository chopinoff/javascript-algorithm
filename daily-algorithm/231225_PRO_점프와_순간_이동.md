## 문제 링크

[![PRO]][Link]

## 문제 해석

-   점프는 한 칸 단위, 움직일 때마다 건전지 사용량 증가
-   순간이동은 현재 이동한 거리의 두 배, 건전지 사용량 없음
-   건전지 사용량을 최소화 하려면 순간이동을 할 수 있는 조건을 만들어야 함
-   순간이동 조건 : 어떤 거리를 반으로 나눌 수 있으면 그 거리는 순간이동 할 수 있음

## 최종 제출 코드

-   이동 과정을 역순으로 생각해 계산했습니다.
    -   뒤로 한 칸 점프 OR 현재 이동한 거리의 1/2만큼 뒤로 순간이동
-   현재 이동한 거리(`dist`)를 반으로 나눌 수 있으면 순간이동을 하고, 나눌 수 없으면 뒤로 한 칸 점프 후 순간이동을 했습니다.
-   시작점 도착 전까지(`dist > 0`) 이동을 반복하고 총 점프 횟수를 `return` 했습니다.

```js
function solution(n) {
    let [jump, dist] = [0, n];
    while (dist > 0) {
        if (dist % 2) {
            jump++;
            dist--;
        }
        dist /= 2;
    }
    return jump;
}
```

## 시간 복잡도

-   `While` 문을 반복할 때마다 `dist`(`=n`)가 절반으로 감소 : O(logn)
-   **∴ O(logn)**

<!---------------------------------------------------------------------------->

[PRO]: https://github.com/chopinoff/js-algorithm/assets/107768516/6bb592e8-21d7-4244-91bb-8708f1f8ebb0
[BOJ]: https://github.com/chopinoff/js-algorithm/assets/107768516/ab4a009d-7575-4362-8a74-ebd2476570e4
[Link]: https://school.programmers.co.kr/learn/courses/30/lessons/12980
